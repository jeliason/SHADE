#' Make a point pattern from x and y coordinates and type of points
#'
#' @param x vector of x coordinates
#' @param y vector of y coordinates
#' @param type vector of types of points
#' @param intensity_factor factor for intensity mask
#'
#' @return spatstat point pattern
#' @export
make_pat <- function(x,y,type,intensity_factor=0.4) {
  stopifnot("type must be a factor!"=is.factor(type))
  window_ss <- spatstat.geom::owin(c(min(x),max(x)),c(min(y),max(y)))
  pat <- spatstat.geom::ppp(x,y,marks = type,window = window_ss)
  
  dens <- spatstat.explore::density.ppp(spatstat.geom::unmark(pat),sigma = spatstat.explore::bw.diggle)
  
  window <- spatstat.geom::owin(mask=spatstat.geom::as.data.frame.im(dens > intensity_factor*spatstat.geom::intensity.ppp(spatstat.geom::unmark(pat))))
  pat <- spatstat.geom::ppp(x,y,marks = type,window = window)
}


#' Make radial basis functions
#'
#' @param max_dist maximum distance to consider
#' @param n_basis_functions number of basis functions
#' @param basis_function_sigma standard deviation for all basis functions
#'
#' @return list of named radial basis functions
#' @export
make_rbfs <- function(max_dist,
                      n_basis_functions=6,
                      basis_function_sigma=8) {
  gaussian_rbf <- function(x, mu, sigma) {
    exp(-(x - mu)^2 / (2 * sigma^2))
  }
  
  basis_function_centers <- seq(0, max_dist, length.out = n_basis_functions)  # Equally spaced centers
  
  rbfs <- lapply(basis_function_centers,\(mu) {
    function(x) {
      gaussian_rbf(x,mu,basis_function_sigma)
    }
  })
  
  names(rbfs) <- paste0("rbf",1:n_basis_functions)
  
  rbfs
}

#' Make regression dataframe from quadrature
#'
#' @param Q logistic regression quadrature scheme, as generated by make_quadrature
#' @param potentials List of potential functions of interaction between two points, takes as input the Euclidean distance between points.
#' @param covariates named list of spatstat im objects, over the same points as in Q.
#'
#' @return list containing data matrix, response vector, offset and spatial fold
#' @export
make_data <- function(Q,
                      potentials,
                      focal_cell=NULL,
                               covariates=NULL,
                               verbose=FALSE) {

  dispersions <- make_dispersions(Q,focal_cell,potentials,verbose)

  Q_focal <- quadscheme.logi(Q$data[marks(Q$data) == focal_cell],Q$dummy[marks(Q$dummy) == focal_cell])
  marks(Q_focal$data) <- droplevels(marks(Q_focal$data))
  marks(Q_focal$dummy) <- droplevels(marks(Q_focal$dummy))
  response <- as.numeric(spatstat.geom::is.data(Q_focal))


  data <- cbind(beta0=1,dispersions)
  offset <- log(intensity(subset(Q$dummy,marks == focal_cell))[num_types])
  offset <- rep(offset,nrow(data))
  data_list <- list(data=data,response=response,offset=offset)

  return(data_list)

}

#' Make dispersions dataframe
#'
#' @param Q logistic regression quadrature scheme, as generated by make_quadrature
#' @param potentials List of potential functions of interaction between two points, takes as input the Euclidean distance between points.
#'
#' @return sparse matrix of dispersions
#' @export
make_acyclic_dispersions <- function(Q,
                                     focal_cell,
                                      potentials,
                                      verbose=FALSE) {

  if (!is.factor(spatstat.geom::marks(Q$data))) {
    stop("The marks on the points in Q must be factors.")
  }

  m <- spatstat.geom::marks(Q)
  types <- setdiff(levels(m),focal_cell)

  types_grid <- expand_grid(t1=focal_cell,t2=types)

  Q_focal <- quadscheme.logi(Q$data[marks(Q$data) == focal_cell],Q$dummy[marks(Q$dummy) == focal_cell])
  spatstat.geom::marks(Q_focal$data) <- droplevels(spatstat.geom::marks(Q_focal$data))
  spatstat.geom::marks(Q_focal$dummy) <- droplevels(spatstat.geom::marks(Q_focal$dummy))

  pat_rest <- Q$data[spatstat.geom::marks(Q$data) != focal_cell]
  spatstat.geom::marks(pat_rest) <- droplevels(spatstat.geom::marks(pat_rest))

  print_vb("Calculating pairwise distances...",verbose)
  pd <- spatstat.geom::crossdist(spatstat.geom::union.quad(Q_focal),pat_rest)

  m_data <- spatstat.geom::marks(pat_rest)
  m_all <- spatstat.geom::marks(Q_focal)

  p <- progressr::progressor(length(potentials))
  data <- lapply(1:length(potentials),\(i) {
    print_vb(paste0("Starting potential: ", i), verbose)
    potential <- potentials[[i]]
    nm_pot <- names(potentials)[i]
    pot <- matrix(potential(pd),nrow = nrow(pd))
    print_vb(paste0("Calculated potential: ", i), verbose)

    diag(pot) <- 0

    pot_ix_jx <- lapply(1:nrow(types_grid),\(j) {
      t1 <- types_grid$t1[j]
      t2 <- types_grid$t2[j]
      ix <- which(m_all == t1)
      jx <- which(m_data == t2)

      as.matrix(pot[ix,jx])
    })
    print_vb(paste0("Calculated pot_ix_jx: ", i), verbose)

    print_vb("calculate dispersions", verbose)
    dispersions <- lapply(1:nrow(types_grid),\(j) {
      t1 <- types_grid$t1[j]
      ix <- which(m_all == t1)
      vec <- rep(0,nrow(pot))
      vec[ix] <- rowSums(pot_ix_jx[[j]])
      vec <- Matrix::Matrix(vec,sparse = TRUE)
    }) %>%
      do.call(cbind,.)

    colnames(dispersions) <- paste0(nm_pot,"_",types_grid$t1,"_",types_grid$t2)
    p()
    return(dispersions)

  }) %>%
    do.call(cbind,.)
  nms <- colnames(data)
  xy_part <- stringr::str_extract(nms, "_[A-Za-z0-9+ ]+_[A-Za-z0-9+ ]+")
  ord <- order(xy_part)
  data <- data[,ord]

  return(data)
}
